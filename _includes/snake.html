<div id="snake">
	<h2>Snake</h2>
	<canvas id="canvas" height="500" width="500">
	</canvas>

	<div id="game-over">
		<p>Game over.<br />Your score was {{score}}.</p>
		<button>Go again?</button>
	</div>

	<p id="score">Score: {{score}}</p>
</div>

<script>
var canvas = document.getElementById('canvas');
var context = canvas.getContext('2d');
var snake;

var grid = {
	width: 20,
	height: 20
};

function resetSnake() {
	snake = {
		squares:
			[
				{x: 3, y: 4},
				{x: 2, y: 4},
				{x: 1, y: 4},
			],
		color: '#ffaa00',
		direction: {
			x: 0,
			y: 1
		},
		nextDirection: {
			x: 1,
			y: 0
		},
	};
};

var food = {
	color: '#0534e9'
};

function drawGrid() {
	context.strokeStyle = "#d0d0d0";
	for (var i = 0; i < 50; i++) {
		context.beginPath();
		context.moveTo(0, i*10);
		context.lineTo(500, i*10);
		context.stroke();
		context.closePath();
		context.beginPath();
		context.moveTo(i*10, 0);
		context.lineTo(i*10, 500);
		context.stroke();
		context.closePath();
	}
};

function getWidth() {
	return canvas.width / grid.width;
};

function getHeight() {
	return canvas.height / grid.height;
};

var label = true;
function drawLabel(square) {
	if (!label) {
		return;
	}

	context.fillStyle = food.color;
	context.fillText(
		'x:' + square.x,
		square.x * getWidth() + 5,
		square.y * getHeight() + 10);

	context.fillText(
		'y:' + square.y,
		square.x * getWidth()+ 5,
		square.y * getHeight() + 20);
}

function drawSnake() {
	for (var i = 0; i < snake.squares.length; i++)
	{
		context.fillStyle = snake.color;
		context.fillRect(
			snake.squares[i].x * getWidth() + 1,
			snake.squares[i].y * getHeight() + 1,
			getWidth() - 2,
			getHeight() - 2);

		drawLabel(snake.squares[i]);
	}
};

function drawFood() {
	context.fillStyle = food.color;
	context.fillRect(
		food.x * getWidth() + 1,
		food.y * getHeight() + 1,
		getWidth() - 2,
		getHeight() - 2);
};

function getRandomInt(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}

function moveFood() {
	do {
		food.x = getRandomInt(0, grid.width - 1);
		food.y = getRandomInt(0, grid.height - 1);
	} while (snake.squares.some(function (square) {
		return food.x == square.x
			&& food.y == square.y;
	}))
};

function isCapture(newHead) {
	return newHead.x == food.x
		&& newHead.y == food.y;
};

var gameOver = document.getElementById('game-over');
var scoreDisplay = document.getElementById('score');
var score = 0;

function updateScore(element) {
	console.log('score: ' + score);
	if (!element.templateString) {
		element.templateString = element.innerText;
	}
	element.innerText = element.templateString.replace(
		'{{score}}',
		score);
};

function tryMoveSnake() {
	changeDirection();
	var newHead = {
		x: snake.squares[0].x + snake.direction.x,
		y: snake.squares[0].y + snake.direction.y,
	};
	if (snake.squares.every(function (value) {
		return value.x != newHead.x
			|| value.y != newHead.y;
	})
	&& newHead.x >= 0
	&& newHead.x <= grid.width - 1
	&& newHead.y >= 0
	&& newHead.y <= grid.height - 1) {
		snake.squares.splice(0, 0, newHead);
		if (isCapture(newHead)) {
			moveFood();
			score++;
			updateScore(scoreDisplay);
		}
		else {
			snake.squares.pop();
		}
		return true;
	}
	else {
		updateScore(gameOver.children[0]);
		gameOver.style.display = 'Block';
		return false;
	}
};

var paused = true;

document.onkeydown = function (event) {
	switch (event.keyCode) {
		case 37:
			snake.nextDirection = {x: -1, y: 0};
			return;
		case 38:
			snake.nextDirection = {x: 0, y: -1};
			return;
		case 39:
			snake.nextDirection = {x: 1, y: 0};
			return;
		case 40:
			snake.nextDirection = {x: 0, y: 1};
			return;
		case 32:
			if (paused) {
				play();
			}
			else {
				pause();
			}
			return;
	}
};

function changeDirection() {
	if ((snake.direction.x != 0
		&& snake.nextDirection.x == 0)
		|| (snake.direction.y != 0
		&& snake.nextDirection.y == 0)) {
		snake.direction.x = snake.nextDirection.x;
		snake.direction.y = snake.nextDirection.y;
	}
};

function makeMove() {
	if (!tryMoveSnake()) {
		pause();
	}
	context.clearRect(0, 0, canvas.width, canvas.height);
	drawSnake();
	drawFood();
}

var interval, botInterval;

function pause() {
	paused = true;
	clearInterval(interval);
	clearInterval(botInterval);
}

function play() {
	paused = false;
	interval = setInterval(makeMove, 50);
	botInterval = setInterval(snakeBot, 25);
}

function reset() {
	pause();
	gameOver.style.display = 'None';
	resetSnake();
	moveFood();
	score = 0;
	updateScore(scoreDisplay);
};

gameOver.children[1].onclick = reset;
reset();
play();

var directions = {
	down: {name:'down', x: 0, y: 1},
	up: {name:'up', x: 0, y: -1},
	left: {name:'left', x: -1, y: 0},
	right: {name:'right', x: 1, y: 0}
}

function squareIsInDirection(head, square, direction) {
	return ((head.x == s.x && (s.y - head.y) * d.y) > 0)
		|| ((head.y == s.y && (s.x - head.x) * d.x) > 0);
}

function trapIsPossible(head, tails, direction) {
	if (!tails.some(s => squareIsInDirection(head, s, direction))) {
		return false;
	}

	if (direction.y != 0) {
		for (var tail in tails.filter(s => squareIsInDirection(head, s, direction))) {
			var tailsLeft =
				tails.filter(
					t =>
						t.x > tail.x
						&& t.y != tail.y
						&& t.x < head.x)
					.map(t => t.y);

			var tailsRight =
				tails.filter(t =>
					t.x < tail.x
					&& t.y != tail.y
					&& t.x > head.x)
					.map(t => t.y);

			if (tailsLeft.every(l => tailsRight.some(r => r == l))
				&& tailsRight.every(r => tailsLeft.some(l => l == r))) {
				return true;
			}
		}
	}

	if (direction.x != 0) {
		for (var tail in tails.filter(s => squareIsInDirection(head, s, direction))) {
			var tailsUp =
				tails.filter(
					t =>
						t.y > tail.y
						&& t.x != tail.x
						&& t.y < head.y)
					.map(t => t.x);

			var tailsDown =
				tails.filter(t =>
					t.y < tail.y
					&& t.x != tail.x
					&& t.y > head.y)
					.map(t => t.x);

			if (tailsUp.every(l => tailsDown.some(r => r == l))
				&& tailsDown.every(r => tailsUp.some(l => l == r))) {
				return true;
			}
		}
	}

	return false;
}

function getBotDirection() {
	var head = snake.squares[0];
	var tails = snake.squares.slice(1);

	var xDiff = food.x - head.x;
	var yDiff = food.y - head.y;

	var possibleDirections = [];

	// Filter by boundary
	if (head.x != 0
		&& !tails.some(s => s.x == head.x - 1 && s.y == head.y)) {
		possibleDirections.push(directions.left)
	}

	if (head.x != grid.width - 1
		&& !tails.some(s => s.x == head.x + 1 && s.y == head.y)) {
		possibleDirections.push(directions.right)
	}

	if (head.y != 0
		&& !tails.some(s => s.y == head.y - 1 && s.x == head.x)) {
		possibleDirections.push(directions.up)
	}

	if (head.y != grid.height - 1
		&& !tails.some(s => s.y == head.y + 1 && s.x == head.x)) {
		possibleDirections.push(directions.down)
	}

	// Avoids self-entrapment where detectable
	var desirableDirections = possibleDirections.filter(
		d => !trapIsPossible(head, tails, direction, tails));
	if (desirableDirections.length > 0) {
		possibleDirections = desirableDirections;
	}

	for (var direction of possibleDirections) {
		if (yDiff * direction.y > 0) {
			return direction;
		}
	}

	for (var direction of possibleDirections) {
		if (xDiff * direction.x > 0) {
			return direction;
		}
	}

	if (possibleDirections.length == 0) {
		throw "no directions possible for some reason";
	}

	return possibleDirections[0];
}

function snakeBot() {
	snake.nextDirection = getBotDirection();
};
</script>
